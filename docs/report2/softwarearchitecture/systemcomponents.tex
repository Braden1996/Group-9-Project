\subsection{System Components}
	\subsubsection{Introduction}
		In order to efficiently create a robust and manageable system, it is critical that we consider its individual components and identify how they should interact with one-another. Doing so will aid us in avoiding writing code of poor quality; which would be difficult to follow and debug should something go wrong.
		
		The first step to be made is that of identifying the components of our system. This can sometimes be quite a grey area, as it is not always clear where the functionality of a single component should end. To help avoid restricting ourselves too heavily regarding the role of our system's components, we shall first deeply explore the various design patterns available to us and how they could be integrated to solve some of the problems proposed by the system.
	
		However, as discussed previously, the system is to be built using Python's Django Framework.  Therefore a series of abstractions have already been made available to us; greatly simplifying the overall task of developing the system. Given this, we are now able to focus on designing just the core requirements of the system.
		
		Throughout the remainder of this section, we shall discuss our chosen designs for the system; providing the reasoning for our decisions.
	
	\subsubsection{Components}
		We have decided to adopt Django's design-philosophy and have placed high emphasis on the reusability and "pluggability" of our system's components. These philosophies are very common amongst the open-source scene; due to the ease involved with integration into of projects.
		
		Django specifies that a project is split into many smaller applications, which are each decoupled from the project as a whole. These applications can be extended to work seamlessly with one-another. After extensive study into the system's current state and goals, we have briefly identified several possible applications for our system.
		
		Below is a partially ambiguous description of the functionality for these applications; just to provide some insight as to their role. This shall later be extended upon...
		
		\begin{itemize}
			\item \textbf{Core}:
				\begin{itemize}
					\item Unique to this system's project; not feasibly reusable.
					\item Glues together the functionality of the other applications.
					\item Provide our project with any trivial functionality - such as the view for an index page.
				\end{itemize}

			\item \textbf{LaTeXBook}:
				\begin{itemize}
					\item Contains a parser to read LaTeX files into a Python object tree representation.
					\item An adapter capable of writing the LaTeX objects into a database.
					\item Suitable forms that staff can use to submit their own LaTeX files.
					\item Django views, and templates, capable of reading the LaTeX objects from the database and rendering them into HTML.
				\end{itemize}
				
			\item \textbf{Module}:
				\begin{itemize}
					\item Modules which student users are enrolled into.
					\item Staff users can manage modules.
					\item A module consist of various learning materials which can be browsed.
				\end{itemize} 

			\item \textbf{Homework}:
				\begin{itemize}
					\item Provides tests that student users are able to take.
					\item Staff users can analyse various aspects of the taken tests.
				\end{itemize} 
		\end{itemize}
	
	\subsubsection{Diagram}
		In many cases, it is desirable to visualise the components of a particular system. This is done to create a better understanding of the role for the various components and how they relate to one-another.
		
		The standard convention for these visualisations is through the use of  Unified Modeling Language (UML) diagrams.
		
		Below is a UML diagram which represents the current system. However, please note, to avoid over-complicating the diagram, we have not included the diagram components for many of the objects provided by Django - unless absolutely necessary.