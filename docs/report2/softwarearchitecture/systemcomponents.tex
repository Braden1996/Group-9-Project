\subsection{System Components}
	\subsubsection{Introduction}
		The system, as a whole, can essentially be broken down into a combination of many smaller tasks. These tasks are then able to be grouped together based upon their dependency with one another - we shall call these components. This process is often known as decomposition.
		
		Decomposition allows the programmer to then interact with these smaller, decoupled components as a black-box - as they are only required to be knowledgeable of the interface, rather than the implementation. This is highly beneficial when a working on larger projects, as a team, where it is not very feasible for each programmer to be well-versed regarding the logic involved in the solutions for each task required by the system.
		
		Another note-worthy benefit of decomposition, is that it unlocks the ability for your components to be designed in such a way that they can integrated into other projects - this is known as reusability. The appeal of this idea expands further when we consider that some of these components our system would require have already been created, and submitted, for anybody to use freely. This is one of the major drives in open-source software.
		
		Decomposition plays a key role in many programming languages. For example, most popular programming languages - such as C++, Java and Python - feature some implementation of the object-oriented paradigm. Object-oriented programming provides the programmer with the tools to abstract from the logic involved in using the solutions to particular tasks.
		
		In order for us to efficiently create a robust and manageable system, it is not only critical that we carefully consider all of the individual components that are required. But that we also deeply explore the various design patterns available to us and how we can integrate these into our components so that their interfaces enable them to interact with one-another in an intuitive manner.
		
		The process of identifying the components for our system can sometimes be quite complicated, as it is not always clear where the functionality of a single component should end. To help avoid restricting ourselves too heavily regarding designating the role of our system's components, we should consider the structure, and utilities, Django has already provided us with.
	
		As discussed previously, Django is the Python web-framework in which our system is to be built upon. Therefore a series of abstractions have already been made available to us; greatly simplifying the overall task of developing the system. Given this, we are now able to apply more focus onto the design of the system's core tasks.
		
		Throughout the remainder of this section, we shall discuss the components, and their designs, in greater detail and provide reason as to why we believe the decisions we have made are beneficial.
	
	\subsubsection{Components}
		As we've decided to build our system upon Django's, it's also recommended that we also adopt their design-philosophy and place a high emphasis on the reusability and "pluggability" of our system's components. These philosophies are very common amongst the open-source scene; due to the ease involved with integration into other projects.
		
		Django specifies that a project is split into many smaller components, known as applications. It is often preferred that these applications are decoupled from each-other, and the project as whole, as much as possible. This makes the process of integrating an existing component into a new project much easier and far less time consuming. These applications can then be extended to work seamlessly with one-another.
		
		After an extensive study into the system's current state and goals, we have briefly identified the following possible applications for our system's Django project.
		
		Please note that this is just a brief outline as to the functionality of each application and some ambiguities do exist. However, we can rest-assured as we will later progress upon these and develop a more concise view of the structure for our system to-be.
		
		\begin{itemize}
			\item \textbf{Core}:
				\begin{itemize}
					\item Unique to this system's project; not feasibly reusable.
					\item Glues together the functionality of the other applications.
					\item Provide our project with any trivial functionality - such as the view for an index page.
				\end{itemize}

			\item \textbf{LaTeXBook}:
				\begin{itemize}
					\item Contains a parser to read LaTeX files into a Python object tree representation.
					\item An adapter capable of writing the LaTeX objects into a database.
					\item Suitable forms that staff can use to submit their own LaTeX files.
					\item Django views, and templates, capable of reading the LaTeX objects from the database and rendering them into HTML.
				\end{itemize}
				
			\item \textbf{Module}:
				\begin{itemize}
					\item Modules which student users are enrolled into.
					\item Staff users can manage modules.
					\item A module consist of various learning materials which can be browsed.
				\end{itemize} 

			\item \textbf{Homework}:
				\begin{itemize}
					\item Provides tests that student users are able to take.
					\item Staff users can analyse various aspects of the taken tests.
				\end{itemize} 
		\end{itemize}